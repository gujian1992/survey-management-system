# 逻辑删除功能修复说明

## 🔍 问题分析

### 问题现象
题库删除功能不起作用：
- 单个删除无效
- 批量删除无效
- 被"删除"的题目仍在列表中显示

### 根本原因
Service层的删除方法实现错误：
```java
// ❌ 错误的实现
public boolean deleteQuestion(Long id) {
    QuestionBank question = getById(id);
    if (question == null || question.getDeleted() == 1) {
        throw new BusinessException(ErrorCode.QUESTION_NOT_FOUND);
    }
    
    question.setDeleted(1);           // 手动设置删除标记
    question.setUpdateTime(LocalDateTime.now());
    
    return updateById(question);      // 调用update而不是delete
}
```

**问题**：
1. 使用`updateById`方法而不是MyBatis Plus的逻辑删除
2. 手动设置`deleted = 1`，绕过了MyBatis Plus的逻辑删除机制
3. MyBatis Plus无法识别这是删除操作，不会触发逻辑删除的相关处理

---

## 🛠️ 解决方案

### 1. 修复删除方法
**正确的实现**：
```java
// ✅ 正确的实现
@Override
@Transactional
public boolean deleteQuestion(Long id) {
    QuestionBank question = getById(id);
    if (question == null) {
        throw new BusinessException(ErrorCode.QUESTION_NOT_FOUND);
    }
    
    // 使用MyBatis Plus的逻辑删除功能
    return removeById(id);
}

@Override
@Transactional
public boolean batchDeleteQuestions(List<Long> ids) {
    if (ids == null || ids.isEmpty()) {
        throw new BusinessException(ErrorCode.PARAMETER_INVALID, "请选择要删除的题目");
    }
    
    // 使用MyBatis Plus的批量逻辑删除功能
    return removeByIds(ids);
}
```

### 2. MyBatis Plus逻辑删除机制
**配置（已正确）**：
```yaml
# application.yml
mybatis-plus:
    global-config:
        db-config:
            logic-delete-field: deleted      # 逻辑删除字段名
            logic-delete-value: 1            # 删除后的值
            logic-not-delete-value: 0        # 正常状态的值
```

**实体类配置（已正确）**：
```java
@TableLogic
@Schema(description = "逻辑删除：0-未删除 1-已删除")
private Integer deleted = 0;
```

---

## 🔄 MyBatis Plus逻辑删除工作原理

### 1. 删除操作转换
```java
// 代码调用
removeById(1L);

// 实际执行的SQL
UPDATE question_bank SET deleted = 1 WHERE id = 1 AND deleted = 0;
```

### 2. 查询操作自动过滤
```java
// 代码调用
getById(1L);

// 实际执行的SQL  
SELECT * FROM question_bank WHERE id = 1 AND deleted = 0;
```

### 3. 自定义查询需要手动处理
```java
// Mapper中的自定义查询需要手动添加deleted条件
@Select("SELECT qb.*, u.real_name as creator_name " +
        "FROM question_bank qb " +
        "LEFT JOIN sys_user u ON qb.creator_id = u.id " +
        "WHERE qb.deleted = 0 " +  // ✅ 手动添加逻辑删除条件
        "AND (#{type} IS NULL OR qb.type = #{type}) " +
        "ORDER BY qb.create_time DESC")
IPage<QuestionBank> selectQuestionPage(/*...*/);
```

---

## 📊 修复范围

### 涉及的文件
1. ✅ **QuestionBankServiceImpl.java** - 修复`deleteQuestion`和`batchDeleteQuestions`方法
2. ✅ **QuestionBankMapper.java** - 自定义查询已正确添加`deleted = 0`条件
3. ✅ **QuestionBank.java** - 实体类已正确配置`@TableLogic`注解
4. ✅ **application.yml** - MyBatis Plus逻辑删除配置已正确

### 修复的方法
| 方法 | 修复前 | 修复后 |
|------|--------|--------|
| `deleteQuestion` | 手动设置`deleted=1`+`updateById` | 使用`removeById` |
| `batchDeleteQuestions` | 循环调用`deleteQuestion` | 使用`removeByIds` |
| `getById`等基础方法 | 自动生效 | 自动生效 |
| 自定义查询方法 | 手动添加条件（已正确） | 手动添加条件（已正确） |

---

## 🚀 功能验证

### ✅ 删除功能测试
1. **单个删除**：
   ```bash
   DELETE /api/question-bank/5
   ```
   - 调用`removeById(5)`
   - 执行SQL：`UPDATE question_bank SET deleted = 1 WHERE id = 5 AND deleted = 0`
   - 列表中不再显示该题目

2. **批量删除**：
   ```bash
   DELETE /api/question-bank/batch
   Body: [1, 2, 3]
   ```
   - 调用`removeByIds([1, 2, 3])`
   - 执行SQL：`UPDATE question_bank SET deleted = 1 WHERE id IN (1, 2, 3) AND deleted = 0`
   - 列表中不再显示这些题目

3. **查询过滤**：
   ```bash
   GET /api/question-bank/page
   ```
   - 只返回`deleted = 0`的题目
   - 已删除的题目自动被过滤

---

## 🎯 技术要点

### 1. MyBatis Plus方法对比
```java
// 逻辑删除（推荐）
removeById(id);           // 设置deleted=1
removeByIds(ids);         // 批量设置deleted=1

// 物理删除（慎用）
getBaseMapper().deleteById(id);     // 真正删除记录
getBaseMapper().deleteByIds(ids);   // 批量删除记录
```

### 2. 查询方法自动过滤
```java
// 这些方法自动添加 deleted = 0 条件
getById(id);              // 单个查询
list();                   // 列表查询  
page(page);               // 分页查询
count();                  // 计数查询
```

### 3. 自定义查询处理
```java
// 需要手动添加逻辑删除条件
@Select("SELECT * FROM question_bank WHERE deleted = 0 AND status = 1")
List<QuestionBank> selectActiveQuestions();
```

---

## 📝 最佳实践

### 1. 统一使用MyBatis Plus方法
```java
// ✅ 推荐
return removeById(id);

// ❌ 避免
question.setDeleted(1);
return updateById(question);
```

### 2. 自定义查询添加逻辑删除条件
```java
// ✅ 推荐
@Select("SELECT * FROM question_bank WHERE deleted = 0 AND type = #{type}")
List<QuestionBank> selectByType(@Param("type") Integer type);

// ❌ 错误
@Select("SELECT * FROM question_bank WHERE type = #{type}")  // 缺少deleted条件
List<QuestionBank> selectByType(@Param("type") Integer type);
```

### 3. 异常处理优化
```java
// 修复后：getById自动过滤已删除记录
QuestionBank question = getById(id);
if (question == null) {  // 不存在或已删除
    throw new BusinessException(ErrorCode.QUESTION_NOT_FOUND);
}
```

---

## 🔍 验证SQL

### 1. 删除操作生成的SQL
```sql
-- removeById(5)
UPDATE question_bank SET deleted = 1 WHERE id = 5 AND deleted = 0;

-- removeByIds([1,2,3])  
UPDATE question_bank SET deleted = 1 WHERE id IN (1, 2, 3) AND deleted = 0;
```

### 2. 查询操作生成的SQL
```sql
-- getById(5)
SELECT * FROM question_bank WHERE id = 5 AND deleted = 0;

-- list()
SELECT * FROM question_bank WHERE deleted = 0;
```

---

**✅ 逻辑删除功能修复完成！现在删除操作会正确设置deleted字段，被删除的题目不会在列表中显示。** 